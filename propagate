#!/usr/bin/env python
# the propagator
# by george caley

import os
import sys

# handle command line arguments
# the verbose argument will flip the verbose flag to true for use later in the script
# the help flag will simply print the usage out
verbose = False
if len(sys.argv) > 1:
    args = sys.argv[1:]
    if '-h' in args or '--help' in args:
        print 'usage: %s [-h] [-v]' % sys.argv[0]
        quit()
    if '-v' in args or '--verbose' in args:
        verbose = True

# the spaces/tabs to be used for each indent
indent = ' ' * 2

# this suffix will be appended to any files that must be backed up when in danger of getting overwritten
backup_suffix = '.backup'

# the prefix for all dotfiles
# probably a dot.
dotfile_prefix = '.'

# keep a list of file prefixes and suffixes that are used for exclusion
exclude_prefixes = []
exclude_suffixes = []

print 'propagating...'

# walk through every file and folder within the current folder
for name, subdirs, files in os.walk('.'):
    # ignore .git for obvious reasons
    if name.startswith('./.git'):
        continue

    # go through every file under the current folder
    for filename in files:
        # is the file suitable?
        # check if the conditions defined earlier are all met
        if filename.startswith(dotfile_prefix) and not any([filename.startswith(prefix) for prefix in exclude_prefixes]) and not any([filename.endswith(suffix) for suffix in exclude_suffixes]):
            # reconstruct the full relative path of the current file
            path = '%s/%s' % (name, filename)

            # this_path stores the location of the file within the propagate folder
            this_path = os.path.realpath(path)

            # home_path stores the target location of the file within the user's home folder
            home_path = os.path.expanduser('~/%s' % path[2:])

            # print out the path
            print path[2:]

            # check if the file exists
            if os.path.exists(home_path):
                if os.path.islink(home_path): # is it a symlink?
                    # remove it, symlinks aren't important.
                    # chances are it was generated by the propagator previously
                    if verbose:
                        print '%sRemoving symlink at %s' % (indent, home_path)
                    os.unlink(home_path)
                elif os.path.isfile(home_path): # is it a file?
                    # we must explicitly ask the user what they want to do with the file
                    # store the valid responses from the user:
                    # o for overwrite (overwrites it with our symlink),
                    # s for skip (ignores the file),
                    # b for backup (creates a copy of the file in their home directory with the backup suffix attached),
                    # a for abort (stops the propagator)
                    valid_responses = ['o', 's', 'b', 'a']

                    # stores the user's response
                    response = ''

                    # get the user's response
                    # if they use ^C to exit the input, assume they wish to abort.
                    while response not in valid_responses:
                        try:
                            response = raw_input('%s%s already exists. [O]verwrite, [S]kip, [B]ackup or [A]bort? ' % (indent, home_path)).lower()
                        except KeyboardInterrupt:
                            print
                            response = 'a'

                    if response == 'o': # overwrite
                        print '%sOverwriting %s' % (indent, home_path)
                        os.unlink(home_path)
                    if response == 's': # skip
                        print '%sSkipping %s' % (indent, home_path)
                        continue
                    elif response == 'b': # backup
                        backup_path = home_path + backup_suffix
                        print '%sBacking up %s to %s' % (indent, home_path, backup_path)
                        os.rename(home_path, backup_path) # append the backup suffix to the existing version of the file
                    elif response == 'a': # abort
                        print '%sAborting' % indent
                        quit()
                elif os.path.isdir(home_path): # is it a directory?
                    # if we encounter a directory, there's not much we can do about it...
                    # just skip over it
                    print '%s%s is a directory, skipping' % (indent, home_path)
                    continue
                else:
                    # if we get here, something at home_path exists, but it isn't a symlink, a file, or a folder.
                    # skip just in case
                    print "%sSomething's fishy with %s, skipping" % (indent, home_path)
                    continue

            # the propagator stores the dotfiles within the same folder as the script, and creates symlinks for each dotfile
            # within your home folder.
            if verbose:
                print '%sCreating symlink at %s, pointing to %s' % (indent, home_path, this_path)
            home_path_dir = os.path.expanduser('~/%s' % name) # map the subdirectory within the propagator folder to a subdirectory within the home folder
            if not os.path.exists(home_path_dir):
                # if the folder doesn't already exist, create it, as well as any parent folders as necessary
                if verbose:
                    print '%sCreating directory %s' % (indent, home_path_dir)
                os.makedirs(home_path_dir)

            # finally, create the symlink from this_path to home_path.
            os.symlink(this_path, home_path)

print 'done'
